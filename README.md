# Project_template

Это шаблон для решения проектной работы. Структура этого файла повторяет структуру заданий. Заполняйте его по мере работы над решением.

# Задание 1. Анализ и планирование

<aside>

Чтобы составить документ с описанием текущей архитектуры приложения, можно часть информации взять из описания компании и условия задания. Это нормально.

</aside>

### 1. Описание функциональности монолитного приложения

**Управление отоплением:**

- Пользователи могут удаленно управлять датчиками температуры через REST API
- Система поддерживает полный жизненный цикл сенсоров: создание, чтение, обновление, удаление (CRUD операции)
- Возможность обновления показаний температуры датчиков через отдельный endpoint
- Интеграция с внешним Temperature API для получения актуальных данных о температуре по местоположению
- Автоматическое обогащение данных сенсоров информацией из внешнего API при запросах

**Мониторинг температуры:**

- Пользователи могут просматривать список всех температурных датчиков в системе
- Система поддерживает получение детальной информации о конкретном датчике по ID
- Мониторинг состояния датчиков (active/inactive)
- Отслеживание местоположения датчиков (комнаты: Living Room, Bedroom, Kitchen)
- Система предоставляет health endpoint для проверки работоспособности приложения
- Автоматическое получение текущих показаний температуры из внешних источников

### 2. Анализ архитектуры монолитного приложения

**Технологический стек:**
- **Язык программирования:** Go 1.21
- **База данных:** PostgreSQL с использованием pgxpool для connection pooling
- **HTTP Framework:** Gin для обработки REST API запросов
- **Архитектура:** Монолитная трехслойная архитектура

**Архитектурные слои:**
- **Presentation Layer (handlers/):** Обработка HTTP запросов/ответов, валидация данных, сериализация JSON, оркестрация бизнес-логики
- **Business Logic Layer (services/):** Бизнес-логика интеграции с внешними API, обработка температурных данных
- **Data Access Layer (db/):** Прямая работа с PostgreSQL через нативные SQL запросы, управление подключениями

**Характеристики взаимодействия:**
- **Взаимодействие:** Полностью синхронное, все запросы обрабатываются последовательно
- **Интеграции:** HTTP клиент для обращения к внешнему Temperature API
- **Dependency Injection:** Ручное внедрение зависимостей через конструкторы
- **Обработка ошибок:** Централизованное логирование ошибок, стандартные HTTP коды ответов

**Ограничения:**
- **Масштабируемость:** Ограничена возможностями вертикального масштабирования
- **Развертывание:** Требует полной остановки приложения для обновлений
- **Fault Tolerance:** Отсутствие изоляции сбоев - падение любого компонента влияет на всю систему
- **Технологическая гибкость:** Привязка к единому технологическому стеку

### 3. Определение доменов и границы контекстов

**Основной домен:** Smart Home Management (Управление умным домом)

**Текущие поддомены (As-Is):**
- **Device Registry** - управление датчиками и устройствами (Core Domain)
- **Temperature Monitoring** - мониторинг и получение температурных данных (Core Domain)

**Будущие поддомены (To-Be):**
- **User Management** - управление пользователями и аутентификация (Supporting Domain)
- **Home Management** - управление домами и их конфигурацией (Core Domain)
- **Device Control** - управление различными типами устройств (освещение, ворота, камеры) (Core Domain)
- **Telemetry Management** - сбор и обработка телеметрии от устройств (Core Domain)
- **Scenario Management** - управление автоматическими сценариями работы (Core Domain)
- **External Integration** - интеграция с внешними API и сервисами (Supporting Domain)
- **Notification Service** - уведомления и алерты (Supporting Domain)

**Bounded Contexts:**
- **Device Context** - управление устройствами, их состоянием и конфигурацией
- **Monitoring Context** - сбор, обработка и хранение телеметрических данных
- **Control Context** - выполнение команд и управление устройствами
- **User Context** - управление пользователями, домами и доступами
- **Integration Context** - взаимодействие с внешними системами и API

### 4. Проблемы монолитного решения

**Технические проблемы:**
- **Tight Coupling (Тесная связанность):** Handlers напрямую зависят от DB и Services, изменения в одном компоненте требуют модификации других
- **Single Point of Failure:** Сбой любого компонента (БД, внешний API) приводит к недоступности всей системы
- **Отсутствие масштабируемости:** Невозможно масштабировать отдельные функции независимо
- **Технологические ограничения:** Привязка к Go и PostgreSQL ограничивает выбор оптимальных технологий для разных задач

**Бизнес-проблемы:**
- **Медленная разработка:** Команды не могут работать над разными функциями независимо
- **Сложность развертывания:** Обновление любой функции требует остановки всей системы
- **Ограниченная функциональность:** Текущий монолит поддерживает только температурные датчики, что не соответствует планам расширения

**Операционные проблемы:**
- **Сложная диагностика:** Логи всех компонентов смешаны, трудно изолировать проблемы
- **Ограниченный мониторинг:** Отсутствие детального мониторинга отдельных функций
- **Проблемы с нагрузкой:** Высокая нагрузка на одну функцию влияет на производительность всей системы

### 5. Визуализация контекста системы — диаграмма С4

[C4 Context Diagram](https://www.planttext.com?text=hLLHZzeu47xdLqpHFS2gsRJNtijA9vK2Mz2nkvHahxedP8X9B3bsQZkmKNN__MQS1CB2LVTm-sGyavdl--ORxoVhc75bBdjlXDhACk6GELVOkp0qx72R2fULcz9oizNASULkjpeF2yaKVHDObqYn2SSVWoLTFJyimfnPnmrUhSVqnOkxBQXwxqt2Tq9nc4p_d8-V7gF_qCQL1KlCXrCxWT5WXnc1BOnmtBRT4hwdc3rskNzwZ4VVfj7Jm_H_RUJls85RdVFWjvDcBQimrJNVoqYXhKiDjz_bgumErf2GsP_47SyBRfWh3Lzd8ir-ahgLkamQyHUZlvwUu_MtUJnRBwPVfe-JmR3NSy993kEFq4mA9eAbXkKGG9IZAs26BE51AorHDXYCR32t-DqICMero32g3ugRjz2VjUS-_fYg18W8738DELCivHOe6pBEd50fCCp8jH9E6miTJc1uhXsN5PRvfPR-zxxNf3zisx8a5mgxH1LE98SH_HJMOG7jkpyq3MqTnqdkH5fYM6ZLROmuhdNfrNNNdtMf4cQgWIKfY5yTeCudSQPRNVVf3-573_2lpXhaZMhdwQsMXFEB1bOKKcnhP2vZxYXMLnBBbIMP27fXz5uacB2QHZ6CbdFOQTE8TXINd6sqx99BDJBx-yXj-k86dHPOXwRsWWPNJ4BSQOuXmXfdmYH1WJmgn6DmsNY3XHeQpcJW1FBhuawOOx2fGEgQOHUFzoP2keudgXbJtqwzvfRWBBFAecuIvZe6l_ieoU3zktTGucZj48J2PqrAdk39EyzweRhmhhlWzNuTCKus7YMHsZ3B2KIzpz7N1KoQMy8MOL5odqVhHNXxxi5waeqx4QRZNG2dLuAykEAoksOTKnrTtcgr5_nWBmP0Y6Pnl8p2rZ5ObgesMzIjsEvZ0mtj92dGUlACnB_MFHMyCDWzTzkC2fN6uCjxXlNS9tNffk8rOtHWhtYXZNlzYZ0ofcrBNM3hZB6ULsYuCuBlpoVdv_br4SPZAj5Jj6K6NU50xuuOSEjlRiODf_jIROa4mqXrTtE3mG36g-S9Q8_Ep_-r5PiP-jpLrLqwcHN0fytnmKwRD-r0ZpDljzUTRw_FdlbHTgjmbHHQAEV3KQMscK4wfKNflfVSEjfkN2fBkLh9geSV0F5lL91yvqMu78wNepx3eXcfRPLOY3rLN6cTms0-kOFtGt__cIVcUFVhi27vXo33gFhsGvqPuSAKzWuOohpdeL3reOFl4nxndnxy0m00)

Диаграмма контекста показывает взаимодействие монолитного приложения Smart Home с внешними участниками: пользователями (веб-клиенты), температурными датчиками и внешним Temperature API. Диаграмма отражает текущее состояние системы (As-Is) и демонстрирует основные потоки данных и управления в экосистеме.

# Задание 2. Проектирование микросервисной архитектуры

В этом задании вам нужно предоставить только диаграммы в модели C4. Мы не просим вас отдельно описывать получившиеся микросервисы и то, как вы определили взаимодействия между компонентами To-Be системы. Если вы правильно подготовите диаграммы C4, они и так это покажут.

**Диаграмма контейнеров (Containers)**

Добавьте диаграмму.

**Диаграмма компонентов (Components)**

Добавьте диаграмму для каждого из выделенных микросервисов.

**Диаграмма кода (Code)**

Добавьте одну диаграмму или несколько.

# Задание 3. Разработка ER-диаграммы

Добавьте сюда ER-диаграмму. Она должна отражать ключевые сущности системы, их атрибуты и тип связей между ними.

# Задание 4. Создание и документирование API

### 1. Тип API

Укажите, какой тип API вы будете использовать для взаимодействия микросервисов. Объясните своё решение.

### 2. Документация API

Здесь приложите ссылки на документацию API для микросервисов, которые вы спроектировали в первой части проектной работы. Для документирования используйте Swagger/OpenAPI или AsyncAPI.

# Задание 5. Работа с docker и docker-compose

Перейдите в apps.

Там находится приложение-монолит для работы с датчиками температуры. В README.md описано как запустить решение.

Вам нужно:

1) сделать простое приложение temperature-api на любом удобном для вас языке программирования, которое при запросе /temperature?location= будет отдавать рандомное значение температуры.

Locations - название комнаты, sensorId - идентификатор названия комнаты

```
	// If no location is provided, use a default based on sensor ID
	if location == "" {
		switch sensorID {
		case "1":
			location = "Living Room"
		case "2":
			location = "Bedroom"
		case "3":
			location = "Kitchen"
		default:
			location = "Unknown"
		}
	}

	// If no sensor ID is provided, generate one based on location
	if sensorID == "" {
		switch location {
		case "Living Room":
			sensorID = "1"
		case "Bedroom":
			sensorID = "2"
		case "Kitchen":
			sensorID = "3"
		default:
			sensorID = "0"
		}
	}
```

2) Приложение следует упаковать в Docker и добавить в docker-compose. Порт по умолчанию должен быть 8081

3) Кроме того для smart_home приложения требуется база данных - добавьте в docker-compose файл настройки для запуска postgres с указанием скрипта инициализации ./smart_home/init.sql

Для проверки можно использовать Postman коллекцию smarthome-api.postman_collection.json и вызвать:

- Create Sensor
- Get All Sensors

Должно при каждом вызове отображаться разное значение температуры

Ревьюер будет проверять точно так же.


# **Задание 6. Разработка MVP**

Необходимо создать новые микросервисы и обеспечить их интеграции с существующим монолитом для плавного перехода к микросервисной архитектуре. 

### **Что нужно сделать**

1. Создайте новые микросервисы для управления телеметрией и устройствами (с простейшей логикой), которые будут интегрированы с существующим монолитным приложением. Каждый микросервис на своем ООП языке.
2. Обеспечьте взаимодействие между микросервисами и монолитом (при желании с помощью брокера сообщений), чтобы постепенно перенести функциональность из монолита в микросервисы. 

В результате у вас должны быть созданы Dockerfiles и docker-compose для запуска микросервисов. 